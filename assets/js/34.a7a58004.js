(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{452:function(t,s,a){"use strict";a.r(s);var n=a(2),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),s("p",[t._v("相信小伙伴们都接触过"),s("code",[t._v("npm/yarn")]),t._v("，这两种包管理工具想必是大家工作中用的最多的包管理工具，"),s("code",[t._v("npm")]),t._v("作为"),s("code",[t._v("node")]),t._v("官方的包管理工具，它是随着node的诞生一起出现在大家的视野中，而"),s("code",[t._v("yarn")]),t._v("的出现则是为了解决"),s("code",[t._v("npm")]),t._v("带来的诸多问题，虽然"),s("code",[t._v("yarn")]),t._v("提高了依赖包的安装速度与使用体验，但它依旧没有解决"),s("code",[t._v("npm")]),t._v("的依赖重复安装等致命问题。"),s("strong",[t._v("pnpm")]),t._v("的出现完美解决了依赖包重复安装的问题，并且实现了"),s("code",[t._v("yarn")]),t._v("带来的所有优秀体验，所以说"),s("strong",[t._v("pnpm才是前端工程化项目的未来")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("如果这篇文章有帮助到你，❤️关注+点赞❤️鼓励一下作者，文章公众号首发，关注 "),s("code",[t._v("前端南玖")]),t._v(" 第一时间获取最新文章～")])]),t._v(" "),s("h2",{attrs:{id:"npm-与-yarn-存在的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#npm-与-yarn-存在的问题"}},[t._v("#")]),t._v(" npm 与 yarn 存在的问题")]),t._v(" "),s("h3",{attrs:{id:"早期的npm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#早期的npm"}},[t._v("#")]),t._v(" 早期的npm")]),t._v(" "),s("p",[t._v("在npm@3之前，"),s("code",[t._v("node_modules")]),t._v("结构可以说是"),s("code",[t._v("整洁")]),t._v("、"),s("code",[t._v("可预测")]),t._v("的，因为当时的依赖结构是这样的：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("node_modules \n└─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" \n   ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n   ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json \n   └─ node_modules \n       └─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" \n       ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n       └─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json\n └─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("C")]),t._v(" \n   ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n   ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json \n   └─ node_modules \n       └─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" \n       ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n       └─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json\n")])])]),s("p",[t._v("每个依赖下面都维护着自己的"),s("code",[t._v("node_modules")]),t._v("，这样看起来确实非常整洁，但同时也带来一些较为严重的问题：")]),t._v(" "),s("ul",[s("li",[t._v("依赖包重复安装")]),t._v(" "),s("li",[t._v("依赖层级过多")]),t._v(" "),s("li",[t._v("模块实例无法共享")])]),t._v(" "),s("h4",{attrs:{id:"依赖包重复安装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖包重复安装"}},[t._v("#")]),t._v(" 依赖包重复安装")]),t._v(" "),s("p",[t._v("从上面的依赖结构我们可以看出，依赖A与依赖C同时引用了依赖B，此时的依赖B会被下载两次。此刻我们想想要是某一个依赖被引用了n次，那么它就需要被下载n次。（此时心里是不是在想，怎么会有如此坑的设计）")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12c0ee79e66f4ce7b8cd37b1cfac66ff~tplv-k3u1fbpfcp-watermark.image?",alt:"01203040_0.jpeg"}})]),t._v(" "),s("h4",{attrs:{id:"依赖层级过多"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖层级过多"}},[t._v("#")]),t._v(" 依赖层级过多")]),t._v(" "),s("p",[t._v("我们再来看另外一种依赖结构：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("node_modules \n└─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" \n   ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n   ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json \n   └─ node_modules \n       └─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" \n       ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n       ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json\n       └─ node_modules \n           └─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("C")]),t._v(" \n           ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n           ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json \n           └─ node_modules \n               └─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("D")]),t._v(" \n               ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n               └─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json\n")])])]),s("p",[t._v("这种依赖层级少还能接受，要是依赖层级多了，这样一层一层嵌套下去，就像一个依赖地狱，不利于维护。")]),t._v(" "),s("h3",{attrs:{id:"npm-3与yarn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#npm-3与yarn"}},[t._v("#")]),t._v(" npm@3与yarn")]),t._v(" "),s("p",[t._v("为了解决上述问题，"),s("code",[t._v("npm3")]),t._v("与"),s("code",[t._v("yarn")]),t._v("都选择了扁平化结构，也就是说现在我们看到的"),s("code",[t._v("node_modules")]),t._v("里面的结构不再有依赖嵌套了，都是如下依赖结构：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("node_modules \n└─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v("  \n    ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n    ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json \n    └─ node_modules \n└─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("C")]),t._v("   \n    ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n    ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json \n    └─ node_modules \n└─ 依赖"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" \n    ├─ index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js \n    ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json \n    └─ node_modules \n")])])]),s("p",[s("code",[t._v("node_modules")]),t._v("下所有的依赖都会平铺到同一层级。由于require寻找包的机制，如果A和C都依赖了B，那么A和C在自己的node_modules中未找到依赖C的时候会向上寻找，并最终在与他们同级的node_modules中找到依赖包C。 这样"),s("strong",[t._v("就不会出现重复下载的情况。而且依赖层级嵌套也不会太深。因为没有重复的下载，所有的A和C都会寻找并依赖于同一个B包。自然也就解决了实例无法共享数据的问题")])]),t._v(" "),s("p",[t._v("由于这个扁平化结构的特点，想必大家都遇到了这样的体验，自己明明就只安装了一个依赖包，打开"),s("code",[t._v("node_modules")]),t._v("文件夹一看，里面却有一大堆。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d437870db584278b54081d41655e875~tplv-k3u1fbpfcp-watermark.image?",alt:"nz2.jpeg"}})]),t._v(" "),s("p",[t._v("这种扁平化结构虽然是解决了之前的嵌套问题，但同时也带来了另外一些问题：")]),t._v(" "),s("ul",[s("li",[t._v("依赖结构的不确定性")]),t._v(" "),s("li",[t._v("扁平化算法的复杂度增加")]),t._v(" "),s("li",[t._v("项目中仍然可以非法访问没有声明过的依赖包(幽灵依赖)")])]),t._v(" "),s("h4",{attrs:{id:"依赖结构的不确定性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖结构的不确定性"}},[t._v("#")]),t._v(" 依赖结构的不确定性")]),t._v(" "),s("p",[t._v("这个怎么理解，为什么会产生这种问题呢？我们来仔细想想，加入有如下一种依赖结构：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e893818b85174667a3e3cc969a24ddfc~tplv-k3u1fbpfcp-watermark.image?",alt:"依赖1.png"}})]),t._v(" "),s("p",[t._v("A包与B包同时依赖了C包的不同版本，"),s("strong",[t._v("由于同一目录下不能出现两个同名文件，所以这种情况下同一层级只能存在一个版本的包，另外一个版本还是要被嵌套依赖。")])]),t._v(" "),s("p",[t._v("那么问题又来了，既然是要一个扁平化一个嵌套，那么这时候是如何确定哪一个扁平化哪一个嵌套的呢？")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46ddd96fc35c4410b5220a21e162c6c8~tplv-k3u1fbpfcp-watermark.image?",alt:"依赖2.png"}})]),t._v(" "),s("p",[t._v("这两种结构都有可能，准确点说"),s("strong",[t._v("哪个版本的包被提升，取决于包的安装顺序！")])]),t._v(" "),s("p",[t._v("这就是为什么会产生依赖结构的"),s("code",[t._v("不确定")]),t._v("问题，也是 "),s("code",[t._v("lock 文件")]),t._v("诞生的原因，无论是"),s("code",[t._v("package-lock.json")]),t._v("(npm 5.x 才出现)还是"),s("code",[t._v("yarn.lock")]),t._v("，都是为了保证 install 之后都产生确定的"),s("code",[t._v("node_modules")]),t._v("结构。")]),t._v(" "),s("p",[t._v("尽管如此，npm/yarn 本身还是存在"),s("code",[t._v("扁平化算法复杂")]),t._v("和"),s("code",[t._v("package 非法访问")]),t._v("的问题，影响性能和安全。")]),t._v(" "),s("h2",{attrs:{id:"pnpm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pnpm"}},[t._v("#")]),t._v(" pnpm")]),t._v(" "),s("p",[t._v("前面说了那么多的"),s("code",[t._v("npm")]),t._v("与"),s("code",[t._v("yarn")]),t._v("的缺点，现在再来看看pnpm是如何解决这些尴尬问题的。")]),t._v(" "),s("h3",{attrs:{id:"什么是pnpm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是pnpm"}},[t._v("#")]),t._v(" 什么是pnpm")]),t._v(" "),s("blockquote",[s("p",[t._v("快速的，节省磁盘空间的包管理工具")])]),t._v(" "),s("p",[t._v("就这么简单，说白了它跟"),s("code",[t._v("npm")]),t._v("与"),s("code",[t._v("yarn")]),t._v("没有区别，都是包管理工具。但它的独特之处在于：")]),t._v(" "),s("ul",[s("li",[t._v("包安装速度极快")]),t._v(" "),s("li",[t._v("磁盘空间利用非常高效")])]),t._v(" "),s("h3",{attrs:{id:"特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),s("h4",{attrs:{id:"安装包速度快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安装包速度快"}},[t._v("#")]),t._v(" 安装包速度快")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c438669fdf7c4052a8122cfaecb7e709~tplv-k3u1fbpfcp-watermark.image?",alt:"p1.png"}})]),t._v(" "),s("p",[t._v("从上图可以看出，"),s("code",[t._v("pnpm")]),t._v("的包安装速度明显快于其它包管理工具。那么它为什么会比其它包管理工具快呢？")]),t._v(" "),s("p",[t._v("我们来可以来看一下各自的安装流程")]),t._v(" "),s("ul",[s("li",[t._v("npm/yarn")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fb59639b17c46248cf912adc9f7cf6c~tplv-k3u1fbpfcp-watermark.image?",alt:"npm&yarn.png"}})]),t._v(" "),s("ol",[s("li",[s("p",[t._v("resolving：首先他们会解析依赖树，决定要fetch哪些安装包。")])]),t._v(" "),s("li",[s("p",[t._v("fetching：安装去fetch依赖的tar包。这个阶段可以同时下载多个，来增加速度。")])]),t._v(" "),s("li",[s("p",[t._v("wrting：然后解压包，根据文件构建出真正的依赖树，这个阶段需要大量文件IO操作。")])])]),t._v(" "),s("ul",[s("li",[t._v("pnpm")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/747e0b3d70224bbf835b8d2b8a79d4db~tplv-k3u1fbpfcp-watermark.image?",alt:"pnpm.png"}})]),t._v(" "),s("p",[t._v("上图是pnpm的安装流程，可以看到针对每个包的三个流程都是平行的，所以速度会快很多。当然pnpm会多一个阶段，就是通过链接组织起真正的依赖树目录结构。")]),t._v(" "),s("h4",{attrs:{id:"磁盘空间利用非常高效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#磁盘空间利用非常高效"}},[t._v("#")]),t._v(" 磁盘空间利用非常高效")]),t._v(" "),s("p",[t._v("pnpm 内部使用"),s("code",[t._v("基于内容寻址")]),t._v("的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于:")]),t._v(" "),s("ul",[s("li",[t._v("不会重复安装同一个包。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 "),s("code",[t._v("hardlink")]),t._v("。")]),t._v(" "),s("li",[t._v("即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 "),s("code",[t._v("hardlink")]),t._v("，仅仅写入那"),s("code",[t._v("一个新增的文件")]),t._v("。")])]),t._v(" "),s("h4",{attrs:{id:"支持monorepo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#支持monorepo"}},[t._v("#")]),t._v(" 支持monorepo")]),t._v(" "),s("p",[t._v("pnpm 与 npm/yarn 另外一个很大的不同就是支持了 monorepo，pnpm内置了对monorepo的支持，只需在工作空间的根目录创建pnpm-workspace.yaml和.npmrc配置文件，同时还支持多种配置，相比较lerna和yarn workspace，pnpm解决monorepo的同时，也解决了传统方案引入的问题。")]),t._v(" "),s("blockquote",[s("p",[t._v("monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的"),s("code",[t._v("packages")]),t._v("目录下，那么一个子项目就代表一个"),s("code",[t._v("package")]),t._v("。")])]),t._v(" "),s("h3",{attrs:{id:"依赖管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖管理"}},[t._v("#")]),t._v(" 依赖管理")]),t._v(" "),s("p",[t._v("pnpm使用的是npm version 2.x类似的嵌套结构，同时使用.pnpm 以平铺的形式储存着所有的包。然后使用Store + Links和文件资源进行关联。简单说pnpm把会包下载到一个公共目录，如果某个依赖在 sotre 目录中存在了话，那么就会直接从 store 目录里面去 hard-link，避免了二次安装带来的时间消耗，如果依赖在 store 目录里面不存在的话，就会去下载一次。通过Store + hard link的方式，使得项目中不存在NPM依赖地狱问题，从而完美解决了npm3+和yarn中的包重复问题。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b0f8ce7a6164ce99f726459927cb5e7~tplv-k3u1fbpfcp-watermark.image?",alt:"store.jpeg"}})]),t._v(" "),s("p",[t._v("我们分别用"),s("code",[t._v("npm")]),t._v("与"),s("code",[t._v("pnpm")]),t._v("来安装vite对比看一下")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("npm")]),t._v(" "),s("th",[t._v("pnpm")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d44c6e37608d4e968928ac9280dc6631~tplv-k3u1fbpfcp-watermark.image?",alt:"npm-demo.png"}})]),t._v(" "),s("td",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a104a288f4488297401d417d6f1a89~tplv-k3u1fbpfcp-watermark.image?",alt:"pnpm-demo.png"}})])]),t._v(" "),s("tr",[s("td",[t._v("所有依赖包平铺在"),s("code",[t._v("node_modules")]),t._v("目录，包括直接依赖包以及其他次级依赖包")]),t._v(" "),s("td",[s("code",[t._v("node_modules")]),t._v("目录下只有"),s("code",[t._v(".pnpm")]),t._v("和直接依赖包，没有其他次级依赖包")])]),t._v(" "),s("tr",[s("td",[t._v("没有符号链接（软链接）")]),t._v(" "),s("td",[t._v("直接依赖包的后面有符号链接（软链接）的标识")])])])]),t._v(" "),s("p",[t._v("pnpm安装的"),s("code",[t._v("vite")]),t._v(" 所有的依赖都软链至了 "),s("code",[t._v("node_modules/.pnpm/")]),t._v(" 中的对应目录。 把 "),s("code",[t._v("vite")]),t._v(" 的依赖放置在同一级别避免了循环的软链。")]),t._v(" "),s("h4",{attrs:{id:"软链接-和-硬链接-机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#软链接-和-硬链接-机制"}},[t._v("#")]),t._v(" 软链接 和 硬链接 机制")]),t._v(" "),s("p",[t._v("pnpm 是通过 hardlink 在全局里面搞个 store 目录来存储 node_modules 依赖里面的 hard link 地址，然后在引用依赖的时候则是通过 symlink 去找到对应虚拟磁盘目录下(.pnpm 目录)的依赖地址。")]),t._v(" "),s("p",[t._v("这两者结合在一起工作之后，假如有一个项目依赖了 "),s("code",[t._v("A@1.0.0")]),t._v(" 和 "),s("code",[t._v("B@1.0.0")]),t._v(" ，那么最后的 node_modules 结构呈现出来的依赖结构可能会是这样的:")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("node_modules\n└── "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// symlink to .pnpm/A@1.0.0/node_modules/A")]),t._v("\n└── "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// symlink to .pnpm/B@1.0.0/node_modules/B")]),t._v("\n└── "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pnpm\n    ├── "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v("@"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v(".0")]),t._v("\n    │   └── node_modules\n    │       └── "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("store"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v("\n    │           ├── index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js\n    │           └── "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json\n    └── "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v("@"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v(".0")]),t._v("\n        └── node_modules\n            └── "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("store"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v("\n                ├── index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("js\n                └── "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("package")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("json\n")])])]),s("p",[s("code",[t._v("node_modules")]),t._v(" 中的 A 和 B 两个目录会软连接到 .pnpm 这个目录下的真实依赖中，而这些真实依赖则是通过 hard link 存储到全局的 store 目录中。")]),t._v(" "),s("h4",{attrs:{id:"store"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#store"}},[t._v("#")]),t._v(" store")]),t._v(" "),s("p",[s("strong",[s("code",[t._v("pnpm")]),t._v("下载的依赖全部都存储到"),s("code",[t._v("store")]),t._v("中去了，"),s("code",[t._v("store")]),t._v("是"),s("code",[t._v("pnpm")]),t._v("在硬盘上的公共存储空间。")])]),t._v(" "),s("p",[s("code",[t._v("pnpm")]),t._v("的"),s("code",[t._v("store")]),t._v("在Mac/linux中默认会设置到"),s("code",[t._v("{home dir}>/.pnpm-store/v3")]),t._v("；windows下会设置到当前盘符的根目录下。使用名为 .pnpm-store的文件夹名称。")]),t._v(" "),s("p",[t._v("项目中所有"),s("code",[t._v(".pnpm/依赖名@版本号/node_modules/")]),t._v("下的软连接都会连接到"),s("code",[t._v("pnpm")]),t._v("的"),s("code",[t._v("store")]),t._v("中去。")]),t._v(" "),s("blockquote",[s("p",[t._v("原文首发地址"),s("a",{attrs:{href:"https://mp.weixin.qq.com/s/FCXM23JWSkPbUIGriVCPjA",target:"_blank",rel:"noopener noreferrer"}},[t._v("点这里"),s("OutboundLink")],1),t._v("，欢迎大家关注公众号 "),s("strong",[t._v("「前端南玖」")]),t._v("，如果你想进前端交流群一起学习，"),s("a",{attrs:{href:"https://juejin.cn/pin/7072217320155775007",target:"_blank",rel:"noopener noreferrer"}},[t._v("请点这里"),s("OutboundLink")],1)])]),t._v(" "),s("p",[s("strong",[t._v("我是南玖，我们下期见！！！")])])])}),[],!1,null,null,null);s.default=e.exports}}]);