(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{452:function(e,v,n){"use strict";n.r(v);var o=n(2),a=Object(o.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),v("p",[e._v("上篇文章我们了解了"),v("code",[e._v("package.json")]),e._v("，一般与它同时出现的还有一个"),v("code",[e._v("package-lock.json")]),e._v("，这两者又有什么关系呢？下面一起来了解吧。")]),e._v(" "),v("h2",{attrs:{id:"介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("package-lock.json")]),e._v(" 它会"),v("strong",[e._v("在 npm 更改 node_modules 目录树 或者 package.json 时自动生成的")]),e._v(" ，它准确的描述了当前项目npm包的依赖树，并且在随后的安装中会根据 package-lock.json 来安装，保证是相同的一个依赖树，不考虑这个过程中是否有某个依赖有小版本的更新。")])]),e._v(" "),v("h2",{attrs:{id:"为什么需要package-lock-json"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要package-lock-json"}},[e._v("#")]),e._v(" 为什么需要package-lock.json")]),e._v(" "),v("p",[e._v("相信跟多人跟我一样会有一个疑问：为什么有了"),v("code",[e._v("package.json")]),e._v("还需要"),v("code",[e._v("package-lock.json")]),e._v("？实际上两者并不是同一时期提出来的，"),v("code",[e._v("package-lock.json")]),e._v("是在"),v("code",[e._v("npm5")]),e._v("之后才提出来的，从上面MDN的介绍来看，它的出现主要是为了解决依赖的版本管理问题。")]),e._v(" "),v("p",[v("code",[e._v("npm install")]),e._v(" 执行后，会生成一个"),v("code",[e._v("node_modules")]),e._v(" 树，在理想情况下， 希望对于同一个 "),v("code",[e._v("package.json")]),e._v(" 总是生成完全相同 "),v("code",[e._v("node_modules")]),e._v(" 树。在某些情况下，确实如此。但在多数情况下，"),v("code",[e._v("npm")]),e._v(" 无法做到这一点。有以下两个原因：")]),e._v(" "),v("ul",[v("li",[e._v("某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 "),v("code",[e._v("1.0.5")]),e._v(" 版本，"),v("code",[e._v("package.json")]),e._v(" 中的配置项为 "),v("code",[e._v("A: '^1.0.5'")]),e._v("，团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 "),v("code",[e._v("1.0.8")]),e._v("，根据 "),v("code",[e._v("package.json")]),e._v(" 中的 "),v("code",[e._v("semver-range version")]),e._v(" 规范，此时第二个人 "),v("code",[e._v("npm install")]),e._v(" 后 A 的版本为 "),v("code",[e._v("1.0.8")]),e._v("，可能会造成因为依赖版本不同而导致的 bug")]),e._v(" "),v("li",[e._v("针对上面的问题，可能有的小伙伴会觉得把 A 的版本号固定为 "),v("code",[e._v("A: '1.0.5'")]),e._v(" 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 "),v("code",[e._v("2.1.3")]),e._v(" 版本，但是第二个人下载的时候已经升级到了 "),v("code",[e._v("2.2.5")]),e._v(" 版本，此时生成的 "),v("code",[e._v("node_modules")]),e._v(" 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定")])]),e._v(" "),v("h2",{attrs:{id:"关于依赖的版本"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于依赖的版本"}},[e._v("#")]),e._v(" 关于依赖的版本")]),e._v(" "),v("p",[e._v("我们可以先来了解依赖的版本")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('{\n   "dependencies": {\n    "@nestjs/common": "^10.0.0",\n    "@nestjs/core": "^10.0.0",\n   }\n}\n')])])]),v("p",[e._v("比如我们常见的依赖版本一般长这样，它一般由三部分组成："),v("code",[e._v("major.minor.patch")]),e._v("，依次为主版本号、次版本号、修补版本号。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("主要版本")]),e._v("的更改代表了一个破坏兼容性的大变化。 如果用户不适应主要版本更改，则内容将无法正常工作。")]),e._v(" "),v("li",[v("code",[e._v("次要版本")]),e._v("的更改表示不会破坏任何内容的新功能。")]),e._v(" "),v("li",[v("code",[e._v("修补版本")]),e._v("的更改表示不会破坏任何内容的错误修复。")])]),e._v(" "),v("p",[e._v("比如上面我们看到的"),v("code",[e._v("^10.0.0")]),e._v("，主版本号为10、次版本号为0、修补版本号为0，那"),v("code",[e._v("^")]),e._v("表示什么呢？")]),e._v(" "),v("h3",{attrs:{id:"版本号指定标识符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#版本号指定标识符"}},[e._v("#")]),e._v(" 版本号指定标识符")]),e._v(" "),v("p",[e._v("这个符号其实是用来指定版本范围的，与之对应的有以下符号：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("^")]),e._v(" 会匹配最新的大版本依赖包，比如 "),v("code",[e._v("^1.2.3")]),e._v(" 会匹配所有 "),v("code",[e._v(">=1.1.2 <2.0.0")]),e._v(" 的版本，包括 "),v("code",[e._v("1.3.0")]),e._v("，但是不包括 "),v("code",[e._v("2.0.0")])]),e._v(" "),v("li",[v("code",[e._v("~")]),e._v(" 会匹配最近的小版本依赖包，比如 "),v("code",[e._v("~1.2.3")]),e._v(" 会匹配所有 "),v("code",[e._v(">=1.1.2 <1.2.0")]),e._v(" 的版本，但是不包括 "),v("code",[e._v("1.3.0")])]),e._v(" "),v("li",[v("code",[e._v("*")]),e._v(" 安装最新版本的依赖包，比如 "),v("code",[e._v("*1.2.3")]),e._v(" 会匹配 "),v("code",[e._v("x.x.x")])]),e._v(" "),v("li",[e._v("无符号时，比如 "),v("code",[e._v("1.2.3")]),e._v("，那就是将要使用的确切版本，总是会下载这个版本的依赖包")])]),e._v(" "),v("h2",{attrs:{id:"认识package-lock-json"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#认识package-lock-json"}},[e._v("#")]),e._v(" 认识package-lock.json")]),e._v(" "),v("p",[e._v("这个文件看起来比"),v("code",[e._v("package.json")]),e._v("又大有复杂，动不动就是上万行代码。")]),e._v(" "),v("p",[e._v("我们可以只安装某一个依赖看看它内部长啥样，比如"),v("code",[e._v("axios")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('{\n  "name": "demo",\n  "version": "1.0.0",\n  "lockfileVersion": 1,\n  "requires": true,\n  "dependencies": {\n    "asynckit": {\n      "version": "0.4.0",\n      "resolved": "https://mirrors.tencent.com/npm/asynckit/-/asynckit-0.4.0.tgz",\n      "integrity": "sha1-x57Zf380y48robyXkLzDZkdLS3k="\n    },\n    "axios": {\n      "version": "1.4.0",\n      "resolved": "https://mirrors.tencent.com/npm/axios/-/axios-1.4.0.tgz",\n      "integrity": "sha512-S4XCWMEmzvo64T9GfvQDOXgYRDJ/wsSZc7Jvdgx5u1sd0JwsuPLqb3SYmusag+edF6ziyMensPVqLTSc1PiSEA==",\n      "requires": {\n        "follow-redirects": "^1.15.0",\n        "form-data": "^4.0.0",\n        "proxy-from-env": "^1.1.0"\n      }\n    },\n    "combined-stream": {\n      "version": "1.0.8",\n      "resolved": "https://mirrors.tencent.com/npm/combined-stream/-/combined-stream-1.0.8.tgz",\n      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",\n      "requires": {\n        "delayed-stream": "~1.0.0"\n      }\n    },\n    "delayed-stream": {\n      "version": "1.0.0",\n      "resolved": "https://mirrors.tencent.com/npm/delayed-stream/-/delayed-stream-1.0.0.tgz",\n      "integrity": "sha1-3zrhmayt+31ECqrgsp4icrJOxhk="\n    },\n    "follow-redirects": {\n      "version": "1.15.2",\n      "resolved": "https://mirrors.tencent.com/npm/follow-redirects/-/follow-redirects-1.15.2.tgz",\n      "integrity": "sha512-VQLG33o04KaQ8uYi2tVNbdrWp1QWxNNea+nmIB4EVM28v0hmP17z7aG1+wAkNzVq4KeXTq3221ye5qTJP91JwA=="\n    },\n    "form-data": {\n      "version": "4.0.0",\n      "resolved": "https://mirrors.tencent.com/npm/form-data/-/form-data-4.0.0.tgz",\n      "integrity": "sha512-ETEklSGi5t0QMZuiXoA/Q6vcnxcLQP5vdugSpuAyi6SVGi2clPPp+xgEhuMaHC+zGgn31Kd235W35f7Hykkaww==",\n      "requires": {\n        "asynckit": "^0.4.0",\n        "combined-stream": "^1.0.8",\n        "mime-types": "^2.1.12"\n      }\n    },\n    "mime-db": {\n      "version": "1.52.0",\n      "resolved": "https://mirrors.tencent.com/npm/mime-db/-/mime-db-1.52.0.tgz",\n      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg=="\n    },\n    "mime-types": {\n      "version": "2.1.35",\n      "resolved": "https://mirrors.tencent.com/npm/mime-types/-/mime-types-2.1.35.tgz",\n      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",\n      "requires": {\n        "mime-db": "1.52.0"\n      }\n    },\n    "proxy-from-env": {\n      "version": "1.1.0",\n      "resolved": "https://mirrors.tencent.com/npm/proxy-from-env/-/proxy-from-env-1.1.0.tgz",\n      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg=="\n    }\n  }\n}\n')])])]),v("p",[e._v("从这里我们可以发现，它的"),v("code",[e._v("dependencies")]),e._v("与"),v("code",[e._v("package.json")]),e._v("不一样，它除了"),v("code",[e._v("axios")]),e._v("之外还包含了一些其它的依赖，实际上这些其它的依赖都是"),v("code",[e._v("axios")]),e._v("的依赖或者是它依赖的依赖...")]),e._v(" "),v("p",[e._v("从上面的介绍中我们也能知道，"),v("strong",[e._v("它实际上描述的是当前项目的依赖树")])]),e._v(" "),v("p",[e._v("它有一些与"),v("code",[e._v("package.json")]),e._v("文件中不同的属性，比如：")]),e._v(" "),v("h3",{attrs:{id:"lockfileversion"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lockfileversion"}},[e._v("#")]),e._v(" lockfileVersion")]),e._v(" "),v("blockquote",[v("p",[e._v("一个整数版本，从1开始，该文档的版本号")])]),e._v(" "),v("h3",{attrs:{id:"resolved"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#resolved"}},[e._v("#")]),e._v(" resolved")]),e._v(" "),v("blockquote",[v("p",[e._v("依赖的安装地址，其实就是一个包下载地址")])]),e._v(" "),v("h3",{attrs:{id:"intergrity"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#intergrity"}},[e._v("#")]),e._v(" intergrity")]),e._v(" "),v("blockquote",[v("p",[e._v("表示解压的完整性 Hash 值")])]),e._v(" "),v("h3",{attrs:{id:"dev"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dev"}},[e._v("#")]),e._v(" dev")]),e._v(" "),v("blockquote",[v("p",[e._v("表示该模块是否为顶级模块的开发依赖或者是一个的传递依赖关系")])]),e._v(" "),v("h3",{attrs:{id:"requires"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#requires"}},[e._v("#")]),e._v(" requires")]),e._v(" "),v("blockquote",[v("p",[e._v("依赖包所需要的所有依赖项,对应依赖包 "),v("strong",[e._v("package.json")]),e._v(" 里 "),v("code",[e._v("dependencices")]),e._v(" 中的依赖项")])]),e._v(" "),v("h2",{attrs:{id:"npm-install策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#npm-install策略"}},[e._v("#")]),e._v(" npm install策略")]),e._v(" "),v("p",[e._v("当我们每次使用"),v("code",[e._v("npm install")]),e._v("进行依赖安装的时候，它到底是按照什么规则去帮我们下载依赖的呢？")]),e._v(" "),v("p",[e._v("这里其实有好几个版本，但我们只需要了解最新版本就行了。")]),e._v(" "),v("p",[e._v("先看有无"),v("code",[e._v("lock")]),e._v("文件：")]),e._v(" "),v("p",[v("strong",[e._v("如果有，则对比package.json和package-lock.json")])]),e._v(" "),v("ul",[v("li",[e._v("如果"),v("code",[e._v("package-lock.json")]),e._v("里包版本号符合"),v("code",[e._v("package.json")]),e._v("要求，则直接获取包信息（如果是从远程拉取，则按照"),v("code",[e._v("package-lock.json")]),e._v("，否则以实际缓存的为准），构建依赖树，（注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包）；那么接下来就看"),v("code",[e._v(".npmrc")]),e._v("里有没有缓存，如果有缓存文件，则从缓存文件中拉取内容，否则从远程拉取；并更改"),v("code",[e._v("package-lock。json")]),e._v("版本号")]),e._v(" "),v("li",[e._v("如果版本号不符合要求，则直接从远程拉取，并更新"),v("code",[e._v("package-lock.json")]),e._v("中的版本号")])]),e._v(" "),v("p",[v("strong",[e._v("如果没有，则：")])]),e._v(" "),v("ul",[v("li",[e._v("根据"),v("code",[e._v("package.json")]),e._v("构建依赖树（注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包）")]),e._v(" "),v("li",[e._v("如果缓存中"),v("code",[e._v("（.npmrc）")]),e._v("有，则优先从缓存中读取，否则从远程读取；注意：（如果是从远程拉取，则按照"),v("code",[e._v("package.json")]),e._v("，否则以实际缓存的为准）")])]),e._v(" "),v("p",[v("strong",[e._v("需要注意的是，在使用"),v("code",[e._v("cnpm install")]),e._v("时候，并不会生成 "),v("code",[e._v("package-lock.json")]),e._v(" 文件，也不会根据 "),v("code",[e._v("package-lock.json")]),e._v(" 来安装依赖，它只会根据 "),v("code",[e._v("package.json")]),e._v(" 来安装依赖")])]),e._v(" "),v("h3",{attrs:{id:"场景一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#场景一"}},[e._v("#")]),e._v(" 场景一")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// package.json\n"dependencies": {\n  "vue": "^2.0.0"\n}\n​\n// package-lock.json\n"dependencies": {\n  "vue": {\n      "version": "2.7.14",\n      "resolved": "https://mirrors.tencent.com/npm/vue/-/vue-2.7.14.tgz",\n      "integrity": "sha512-b2qkFyOM0kwqWFuQmgd4o+uHGU7T+2z3T+WQp8UBjADfEv2n4FEMffzBmCKNP0IGzOEEfYjvtcC62xaSKeQDrQ==",\n      "requires": {\n        "@vue/compiler-sfc": "2.7.14",\n        "csstype": "^3.1.0"\n      }\n    }\n}\n​\n')])])]),v("p",[e._v("这种情况下"),v("code",[e._v("package-lock.json")]),e._v("指定的"),v("code",[e._v("2.7.14")]),e._v("在"),v("code",[e._v("^2.0.0")]),e._v("指定的范围内，"),v("code",[e._v("npm install")]),e._v("会安装"),v("code",[e._v("vue2.7.14")]),e._v("版本。")]),e._v(" "),v("h3",{attrs:{id:"场景二"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#场景二"}},[e._v("#")]),e._v(" 场景二")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('// package.json\n"dependencies": {\n  "vue": "^2.2.0"\n}\n​\n// package-lock.json\n"dependencies": {\n  "vue": {\n    "version": "2.1.0",\n    "resolved": "https://mirrors.tencent.com/npm/vue/-/vue-2.1.0.tgz",\n    "integrity": "sha1-KTuj76rKhGqmvL+sRc+FJMxZfj0="\n  }\n}\n​\n')])])]),v("p",[e._v("这种情况下"),v("code",[e._v("package-lock.json")]),e._v("指定的"),v("code",[e._v("2.1.0")]),e._v("不在"),v("code",[e._v("^2.2.0")]),e._v("指定的范围内，"),v("code",[e._v("npm install")]),e._v("会按照"),v("code",[e._v("^2.2.0")]),e._v("的规则去安装最新的"),v("code",[e._v("2.7.14")]),e._v("版本，并且将"),v("code",[e._v("package-lock.json")]),e._v("的版本更新为"),v("code",[e._v("2.7.14")]),e._v("。")]),e._v(" "),v("p",[e._v("现在应该能够理解"),v("code",[e._v("package.json")]),e._v("文件是如何做到对依赖进行版本锁定的吧，我们一般在安装依赖时如果不指定版本，那么安装的版本号并不是固定的而是一个"),v("strong",[e._v("最优版本")]),e._v("，最优版本会在版本前多了一个"),v("code",[e._v("^")]),e._v("或者"),v("code",[e._v("~")]),e._v("符号")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('"dependencies": {\n    "vue": "^2.0.0"\n  }\n')])])]),v("p",[e._v("但我们的"),v("code",[e._v("lock")]),e._v("文件中肯定是会指定一个固定版本进行安装的，一般是改依赖的符合版本范围的最新版本")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('"dependencies": {\n  "vue": {\n    "version": "2.1.0",\n    "resolved": "https://mirrors.tencent.com/npm/vue/-/vue-2.1.0.tgz",\n    "integrity": "sha1-KTuj76rKhGqmvL+sRc+FJMxZfj0="\n  }\n}\n')])])]),v("p",[e._v("至于为什么不直接在"),v("code",[e._v("package.json")]),e._v("中将版本锁定，那是因为你只能指定你安装的依赖的版本，但不能指定你依赖的依赖的版本")]),e._v(" "),v("h2",{attrs:{id:"package-lock-json什么时候会变"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#package-lock-json什么时候会变"}},[e._v("#")]),e._v(" package-lock.json什么时候会变？")]),e._v(" "),v("p",[e._v("开发过程中是不是经常遇到这个文件冲突的，自己明明没改这个文件为啥会冲突？那是因为我们的一些操作会影响到该文件的内容，比如：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("package-lock.json")]),e._v("在"),v("code",[e._v("npm install")]),e._v("的时候会自动生成")])]),e._v(" "),v("ul",[v("li",[e._v("当我们修改依赖位置，比如将部分依赖从"),v("code",[e._v("开发依赖改")]),e._v("成"),v("code",[e._v("生产依赖")]),e._v("，虽然整体上的依赖并未改变，但是也会影响 "),v("code",[e._v("package-lock.json")]),e._v("中依赖的 "),v("code",[e._v("dev")]),e._v(" 字段")])]),e._v(" "),v("ul",[v("li",[e._v("如果我们切换"),v("code",[e._v("npm镜像")]),e._v("时，执行 "),v("code",[e._v("npm install")]),e._v(" 时也会修改 "),v("code",[e._v("package-lock.json")]),e._v("，因为它是会记录我们的依赖包地址的(resolved)")]),e._v(" "),v("li",[e._v("当我们使用"),v("code",[e._v("npm install")]),e._v("添加或"),v("code",[e._v("npm uninstall")]),e._v("移除包的时候，也会修改 "),v("code",[e._v("package-lock.json")])]),e._v(" "),v("li",[e._v("当我们更新某个包的版本的时候，也会修改 "),v("code",[e._v("package-lock.json")])])]),e._v(" "),v("h2",{attrs:{id:"package-lock-json需要提交到仓库吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#package-lock-json需要提交到仓库吗"}},[e._v("#")]),e._v(" package-lock.json需要提交到仓库吗？")]),e._v(" "),v("blockquote",[v("p",[e._v("npm 官网建议：把 "),v("code",[e._v("package-lock.json")]),e._v(" 一起提交到代码库中，不要 ignore。但是在执行 npm publish 的时候，它会被忽略而不会发布出去。")])]),e._v(" "),v("h2",{attrs:{id:"如何查看依赖安装的版本"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何查看依赖安装的版本"}},[e._v("#")]),e._v(" 如何查看依赖安装的版本？")]),e._v(" "),v("p",[e._v("上面我们已经了解到，"),v("code",[e._v("package.json")]),e._v("中保存的依赖版本一般不是一个具体版本，而是一个带有"),v("code",[e._v("^")]),e._v("或"),v("code",[e._v("~")]),e._v("的最优版本，那我们怎么才能知道当前项目依赖安装的具体版本呢？")]),e._v(" "),v("ul",[v("li",[e._v("查看"),v("code",[e._v("package-lock.json")]),e._v("文件，这里保存的是依赖的具体版本")]),e._v(" "),v("li",[e._v("从"),v("code",[e._v("node_modules")]),e._v("文件夹中找到对应依赖的"),v("code",[e._v("package.json")]),e._v("文件，里面的"),v("code",[e._v("version")]),e._v("字段就是该依赖的版本")]),e._v(" "),v("li",[e._v("使用"),v("code",[e._v("npm list --depth 0")]),e._v("查看项目所有的依赖版本")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cec829e73a2b4c8a834283b2771c7307~tplv-k3u1fbpfcp-watermark.image?",alt:"p2-1.png"}})]),e._v(" "),v("p",[v("strong",[e._v("如果这篇文章有帮助到你，❤️关注+点赞❤️鼓励一下作者，关注 "),v("code",[e._v("前端南玖")]),e._v(" 第一时间获取最新文章～")])])])}),[],!1,null,null,null);v.default=a.exports}}]);